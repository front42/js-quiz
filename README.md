# <img src="./javascript.svg" alt="JavaScript" height="23"/>&#8239;Quiz  

1. Что произойдёт при использовании `typeof` с `null`? <details><summary>Вернётся "null"</summary>Не верно, потому что `typeof null` возвращает "object".</details> <details><summary>Вернётся "undefined"</summary>Не верно, потому что `typeof null` возвращает "object", а не "undefined".</details> <details><summary>Вернётся "object"</summary>Верно, потому что это известный "баг" JavaScript, и `typeof null` действительно возвращает "object".</details> <details><summary>Вернётся "error"</summary>Не верно, потому что JavaScript не выдаст ошибку, а вернёт строку "object".</details>

2. Какое ключевое слово используется для создания нового контекста выполнения функции? <details><summary>`function`</summary>Не верно, потому что `function` определяет функцию, а не контекст выполнения.</details> <details><summary>`new`</summary>Верно, потому что при использовании `new` перед функцией создаётся новый объект, и `this` внутри функции будет ссылаться на него.</details> <details><summary>`this`</summary>Не верно, потому что `this` ссылается на текущий контекст выполнения, а не создаёт его.</details>  <details><summary>`create`</summary>Не верно, потому что в JavaScript нет ключевого слова `create` для создания контекстов.</details>

3. Какой метод массива используется для добавления элементов в начало массива? <details><summary>`push()`</summary>Не верно, потому что метод `push()` добавляет элементы в конец массива.</details> <details><summary>`pop()`</summary>Не верно, потому что метод `pop()` удаляет последний элемент из массива.</details> <details><summary>`shift()`</summary>Не верно, потому что метод `shift()` удаляет первый элемент из массива.</details> <details><summary>`unshift()`</summary>Верно, потому что метод `unshift()` добавляет один или несколько элементов в начало массива.</details>

4. Что возвращает метод `Array.prototype.map()`? <details><summary>Новый массив, являющийся результатом вызова указанной функции для каждого элемента исходного массива</summary>Верно, потому что это основное назначение метода `map()`.</details> <details><summary>`undefined`</summary>Не верно, потому что `map()` всегда возвращает новый массив.</details> <details><summary>Исходный массив без изменений</summary>Не верно, потому что `map()` создаёт и возвращает новый массив.</details> <details><summary>Массив, который может быть изменён внутри коллбэка</summary>Не верно, потому что результат работы `map()` не зависит от того, изменяется ли исходный массив в коллбэке.</details>

5. Что такое Closure в JavaScript? <details><summary>Функция, объявленная внутри другой функции</summary>Не совсем верно, поскольку само понятие замыкания включает в себя не только объявление функции внутри другой функции.</details> <details><summary>Объект базового класса `Object`</summary>Не верно, потому что Closure и `Object` относятся к разным аспектам JavaScript.</details> <details><summary>Возможность функции запоминать своё лексическое окружение и иметь к нему доступ, даже когда она выполняется вне его</summary>Верно, потому что это определение замыкания в JavaScript.</details> <details><summary>Специальная конструкция для работы с асинхронным кодом</summary>Не верно, поскольку замыкания используются не только для асинхронного кода.</details>

6. Какие методы существуют для контроля асинхронных операций в JavaScript? <details><summary>`async` и `await`</summary>Да, `async` и `await` используются для упрощения работы с промисами, но используются не только они.</details> <details><summary>`setTimeout` и `setInterval`</summary>Да, эти функции используются для управления асинхронными операциями через задержки и интервалы, но используются не только они.</details> <details><summary>`Promise.all()` и `Promise.race()`</summary>Да, эти методы `Promise` используются для агрегации результатов нескольких промисов, но используются не только они.</details> <details><summary>Все вышеперечисленные</summary>Верно, потому что все указанные варианты используются для управления асинхронными операциями.</details>

7. В чём разница между операторами `==` и `===` в JavaScript? <details><summary>`==` сравнивает по значению, а `===` по типу и значению</summary>Не верно, потому что `==` также учитывает типы после приведения типов.</details> <details><summary>`==` выполняет автоматическое приведение типов, тогда как `===` сравнивает значения и типы без приведения</summary>Верно, это основное различие между этими операторами.</details> <details><summary>`==` используется только для строк, а `===` только для чисел</summary>Не верно, потому что оба оператора могут использоваться для любых типов.</details> <details><summary>Нет разницы, это просто два разных способа написания одного и того же оператора</summary>Не верно, так как между `==` и `===` есть существенное различие в поведении.</details>

8. Что такое `IIFE` в JavaScript? <details><summary>Немедленно вызываемое функциональное выражение</summary>Верно, потому что `IIFE` (Immediately Invoked Function Expression) - это функция, которая выполняется сразу после её создания.</details> <details><summary>Интерфейс внутренней функциональности элемента</summary>Не верно, так как это определение не относится к `IIFE`.</details> <details><summary>Индикатор интерактивной ошибки выполнения</summary>Не верно, `IIFE` не имеет отношения к ошибкам выполнения.</details> <details><summary>Независимо исполняемая файловая среда</summary>Не верно, так как `IIFE` связано с функциями, а не файловыми средами.</details>

9. Какой будет результат сравнения `0 == ""` в JavaScript? <details><summary>`true`</summary>Верно, потому что JavaScript выполнит приведение типов, и 0 и пустая строка будут преобразованы к `false`.</details> <details><summary>`false`</summary>Не верно, несмотря на то, что значения различных типов, после приведения типов они оба считаются ложными значениями.</details> <details><summary>`TypeError`</summary>Не верно, JavaScript не выдаст ошибку типа при сравнении этих значений.</details> <details><summary>`ReferenceError`</summary>Не верно, так как это валидное сравнение значений в JavaScript.</details>

10. Что делает оператор `??` в JavaScript? <details><summary>Сравнивает два значения на равенство без приведения типов</summary>Не верно, оператор `??` не выполняет сравнение.</details> <details><summary>Возвращает правый операнд, если левый не `null` и не `undefined`</summary>Не верно, возвращает левый операнд, если он не `null` и не `undefined`, иначе возвращает правый.</details> <details><summary>Возвращает левый операнд, если он не `null` и не `undefined`, иначе возвращает правый</summary>Верно, это определение оператора нулевого слияния.</details> <details><summary>Удаляет свойство из объекта</summary>Не верно, оператор `??` не используется для удаления свойств из объектов.</details>

11. Каков будет результат выполнения `Boolean([])` в JavaScript? <details><summary>`true`</summary>Верно, потому что пустой массив преобразуется в `true`.</details> <details><summary>`false`</summary>Не верно, пустой массив не является ложным значением.</details> <details><summary>`null`</summary>Не верно, функция `Boolean` не возвращает `null`.</details> <details><summary>`undefined`</summary>Не верно, функция `Boolean` не возвращает `undefined`.</details>

12. Что такое Promise в JavaScript? <details><summary>Callback функция</summary>Не верно, Promise не является callback функцией.</details> <details><summary>Объект, представляющий возможное будущее значение или ошибку</summary>Верно, так как Promise используется для асинхронных операций.</details> <details><summary>Глобальный объект JavaScript</summary>Не верно, Promise является частью JavaScript, но не глобальным объектом.</details> <details><summary>Синтаксическая конструкция для обработки исключений</summary>Не верно, это определение больше подходит для try/catch.</details>

13. Какой метод используется для превращения JSON строки в объект JavaScript? <details><summary>`JSON.parse()`</summary>Верно, `JSON.parse()` преобразует строку JSON в объект JavaScript.</details> <details><summary>`JSON.stringify()`</summary>Не верно, `JSON.stringify()` преобразует объект JavaScript в строку JSON.</details> <details><summary>`Object.fromString()`</summary>Не верно, в JavaScript нет метода `Object.fromString()`.</details> <details><summary>`parseJSON()`</summary>Не верно, правильный метод для этой операции — `JSON.parse()`.</details>

14. Какой метод добавляет один или несколько элементов в конец массива? <details><summary>`unshift()`</summary>Не верно, `unshift()` добавляет элементы в начало массива.</details> <details><summary>`push()`</summary>Верно, так как `push()` добавляет один или несколько элементов в конец массива.</details> <details><summary>`pop()`</summary>Не верно, `pop()` удаляет последний элемент из массива.</details> <details><summary>`shift()`</summary>Не верно, `shift()` удаляет первый элемент из массива.</details>

15. Что такое полифил в контексте веб-разработки? <details><summary>Элемент дизайна в CSS</summary>Не верно, полифил не относится к дизайну.</details> <details><summary>Ошибка в JavaScript</summary>Не верно, полифил не является ошибкой.</details> <details><summary>Фрагмент кода, реализующий функционал, который не поддерживается текущим браузером</summary>Верно, полифилы используются для эмуляции недостающих функций.</details> <details><summary>API браузера для работы с мультимедиа</summary>Не верно, это определение не характеризует полифил.</details>

16. Что такое hoisting в JavaScript? <details><summary>Динамическое назначение контекста выполнения функции</summary>Не верно, hoisting не связан с динамическим назначением контекста.</details> <details><summary>Поднятие объявления переменных и функций в верх текущей области видимости</summary>Верно, hoisting означает поднятие объявлений в начало.</details> <details><summary>Автоматическое преобразование типов при сравнении</summary>Не верно, это процесс, не связанный с hoisting.</details> <details><summary>Способ объявления переменных в ES6</summary>Не верно, hoisting присутствует в JavaScript и до ES6.</details>

17. Что делает оператор `delete` в JavaScript? <details><summary>Удаляет свойство из объекта</summary>Верно, `delete` удаляет указанное свойство из объекта.</details> <details><summary>Вызывает сборщик мусора для удаления неиспользуемых переменных</summary>Не верно, оператор `delete` прямо не влияет на сборку мусора.</details> <details><summary>Удаляет элемент из массива</summary>Не верно, оператор `delete` хоть и удаляет элемент, но оставляет пустой слот.</details> <details><summary>Полностью удаляет переменную из памяти</summary>Не верно, оператор `delete` не может удалить переменные, объявленные через `var`, `let` или `const`.</details>

18. Какой из нижеперечисленных типов данных является примитивным в JavaScript? <details><summary>Строка (String)</summary>Верно, строка является примитивным типом данных.</details> <details><summary>Массив (Array)</summary>Не верно, массивы являются объектами.</details> <details><summary>Объект (Object)</summary>Не верно, объект не является примитивным типом данных.</details> <details><summary>Функция (Function)</summary>Не верно, функции являются объектами высшего порядка.</details>

19. Для чего используется ключевое слово `const` в JavaScript? <details><summary>Для объявления переменной, значение которой не может быть изменено</summary>Верно, `const` создаёт константу, которая не может быть переназначена.</details> <details><summary>Для создания условных конструкций</summary>Не верно, `const` не используется для создания условных конструкций.</details> <details><summary>Для объявления анонимных функций</summary>Не верно, `const` используется для объявления переменных, а не функций.</details> <details><summary>Для определения констант времени выполнения</summary>Не верно, хотя `const` и определяет константу, она должна быть присвоена при объявлении.</details>

20. Как в JavaScript создать копию объекта? <details><summary>`Object.assign({}, obj)`</summary>Верно, это один из способов создать поверхностную копию объекта.</details> <details><summary>`Object.copy(obj)`</summary>Не верно, в JavaScript нет встроенного метода `Object.copy`.</details> <details><summary>`obj.clone()`</summary>Не верно, объекты JavaScript по умолчанию не имеют метода `clone`.</details> <details><summary>`{ ...obj }`</summary>Верно, это современный способ создать поверхностную копию объекта через spread оператор.</details>  

<img src="https://rolling-scopes-school.github.io/front42-JSFE2021Q1/presentation/z/front42.jpg" alt="logo" height="23"/> © *Based on @jegius' labour's lost*